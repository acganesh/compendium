\documentclass[12pt]{article}

\title{CS161 - Algorithms}
\author{Instructor: Mary Wooters; Notes: Adithya Ganesh}

\lhead{CS161}

\newcommand*{\mat}[1]{\begin{pmatrix}#1\end{pmatrix}}

\begin{document}

\section{Divide-and-conquer}

We can solve a problem recursively as follows:

\begin{itemize}
  \item Divide the problem into a number of subproblems.
  \item Conquer the subproblems by solving them recursively.
  \item Combine the solutions to the subproblems.
\end{itemize}

A classic example is the maximum-subarray problem.  Given a list of prices over an $N$-day period, you have the option to buy once and sell once.  What is the optimal strategy?

Brute force: just search over the $\binom{n}{2}$ possible pairs.

Alternatively, just break down the maximum sub-array problem into three cases:
\begin{itemize}
  \item Left subarray case,
  \item Right subarray case,
  \item Cross subarray case.
\end{itemize}

\section{Dynamic programming}

Recall that divide-and-conquer algorithms partition the problem into disjoint subproblems, solve the subproblems recursively, and then combine their solutions to solve the original problem.

In constant, dynamic programming applies when the subproblems overlap.  A DP algorithm solves each subsubproblem juts once and saves it answer in a table.  Most often, DP applies to optimization problems.

{\bf Example.} Given a rod of length $n$ inches and a tbable of prices $p_i$ for $i = 1, \dots, n$, determine the maximize revenue $r_n$ obtained by cutting the rod and selling the pieces.

The idea is to use the fact that $r_n = \max_{1 \leq i \leq n} (p_i + r_{n-i})$.  We can calculate this either bottom-up or top-down.  Bottom-up algorithms sometimes have better constant factors.

\section{Max flow algorithms}

\end{document}
